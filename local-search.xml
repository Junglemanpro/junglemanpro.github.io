<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>archetype_based_ECS</title>
    <link href="/2024/01/16/archetype_based_ECS/"/>
    <url>/2024/01/16/archetype_based_ECS/</url>
    
    <content type="html"><![CDATA[<h2 id="Archetype-based-ECS内存布局"><a href="#Archetype-based-ECS内存布局" class="headerlink" title="Archetype based ECS内存布局"></a>Archetype based ECS内存布局</h2><p><img src="/2024/01/16/archetype_based_ECS/Archetype.png"></p>]]></content>
    
    
    <categories>
      
      <category>render</category>
      
    </categories>
    
    
    <tags>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cascade_shadow_mapping</title>
    <link href="/2024/01/16/cascade-shadow-mapping/"/>
    <url>/2024/01/16/cascade-shadow-mapping/</url>
    
    <content type="html"><![CDATA[<p>让我们近距离观察一下:</p><p><img src="/2024/01/16/cascade-shadow-mapping/worse_shadows.jpg" alt="阴影锯齿"></p><p>阴影的质量不高,因为这种块效应，将其称为透视锯齿，视图空间中的大量像素被映射到阴影贴图中的同一像素，这意味着所有这些像素要么处于阴影中，要么处于光亮中，从而产生块状感。换句话说，由于阴影贴图的分辨率不够高，因此无法充分覆盖视图空间。解决这个问题的一个明显方法是增加阴影贴图的分辨率，但这会增加我们应用程序的内存占用，因此它可能不是最好的做法。</p><p>处理此问题的另一种方法是注意靠近相机的阴影比远处物体的阴影重要得多。无论如何，远处的物体都较小，通常眼睛会聚焦于附近发生的事情，而将其余的视为“背景”。如果我们能找到一种方法，对较近的物体使用专用的阴影贴图，对远处的物体使用不同的阴影贴图，那么第一个阴影贴图将只需要覆盖较小的区域，从而减少我们上面讨论的比率。简而言之，这就是级联阴影贴图（又名 CSM）的全部内容。CSM 被认为是处理透视锯齿的最佳方法之一。让我们看看如何实现它。</p><p>从高层视图来看，我们将把视锥体分割成几个级联（因为它不需要像前面的示例中那样只有两个）。出于本教程的目的，我们将使用三个级联：近、中和远。该算法本身非常通用，因此如果您愿意，可以使用更多级联。每个级联都会被渲染成它自己的私有阴影贴图。阴影算法本身将保持不变，但在从阴影贴图采样深度时，我们需要根据距观察者的距离选择适当的贴图。让我们看一下通用的视锥体：</p><p><img src="/2024/01/16/cascade-shadow-mapping/frustum_3d.png"><br>像往常一样，我们有一个小的近平面和一个更大的远平面。现在让我们从上面看一下同一个平截头体：</p><p><img src="/2024/01/16/cascade-shadow-mapping/frustum_2d.png"><br>下一步是将近平面到远平面的范围分成三部分。我们将其称为近、中、远。另外，我们添加光线方向（右侧的箭头）：</p><p><img src="/2024/01/16/cascade-shadow-mapping/frustum_cascade.png"><br>那么我们如何将每个级联渲染成它自己的私有阴影贴图呢？让我们考虑一下阴影贴图算法中的阴影阶段。我们设置一些东西来从光的角度渲染场景。这意味着使用对象的世界变换、基于光线的视图变换和投影矩阵创建一个 WVP 矩阵。由于本教程基于处理定向光阴影的教程 47，因此投影矩阵将是正交的。一般来说，CSM 在主要光源通常是太阳的户外场景中更有意义，因此在这里使用定向光是很自然的。如果您查看上面的 WVP 矩阵，您会发现所有级联的前两个部分（世界和视图）都是相同的。毕竟，物体在世界中的位置以及基于光源的相机的方向与将视锥体分裂成级联无关。这里重要的只是投影矩阵，因为它定义了最终渲染区域的范围。由于正交投影是使用盒子定义的，我们需要定义三个不同的盒子，它们将被转换为三个不同的正交投影矩阵。这些投影矩阵将用于创建三个 WVP 矩阵，以将每个级联渲染为其自己的阴影贴图。</p><p>最合乎逻辑的做法是使这些框尽可能小，以保持视图像素与阴影贴图像素的比率尽可能低。这意味着为每个级联创建一个沿光方向矢量定向的边界框。让我们为第一个级联创建一个这样的边界框：</p><p><img src="/2024/01/16/cascade-shadow-mapping/frustum_cascade_bounds_1.png"></p><p>现在让我们为第二个级联创建一个边界框：<br><img src="/2024/01/16/cascade-shadow-mapping/frustum_cascade_bounds_2.png"></p><p>最后是最后一个级联的边界框：</p><p><img src="/2024/01/16/cascade-shadow-mapping/frustum_cascade_bounds_3.png"><br>正如您所看到的，由于光线的方向，边界框存在一些重叠，这意味着某些像素将被渲染到多个阴影贴图中。只要单个级联的所有像素完全位于单个阴影贴图中，就没有问题。在着色器中用于阴影计算的阴影贴图的选择将基于像素与实际观看者的距离。</p><p>作为阴影阶段正投影的基础的边界框的计算是该算法中最复杂的部分。这些盒子必须在光空间中描述，因为投影发生在世界和视图变换之后（此时光从原点“起源”并沿正 Z 轴指向）。由于框将被计算为所有三个轴上的最小&#x2F;最大值，因此它们将在光线方向上对齐，这就是我们投影所需的。为了计算边界框，我们需要知道每个级联在光空间中的样子。为此，我们需要执行以下步骤：</p><ol><li>计算视图空间中每个级联的八个角。这很简单，需要简单的三角函数：</li></ol><p><img src="/2024/01/16/cascade-shadow-mapping/frustum1.png"><br>上图表示任意级联（因为每个级联本身基本上是一个截锥体，并且与其他级联共享相同的视场角）。请注意，我们是从上往下看 XZ 平面。我们需要计算 X 1和 X 2：</p><p><img src="/2024/01/16/cascade-shadow-mapping/calc1.png"></p><p><img src="/2024/01/16/cascade-shadow-mapping/calc2.png"></p><p>这为我们提供了视图空间中级联的八个坐标的 X 和 Z 分量。对垂直视场角使用类似的数学运算，我们可以获得 Y 分量并最终确定坐标。</p><ol start="2"><li>现在我们需要将级联坐标从视图空间转换回世界空间。假设观察者的方向使得在世界空间中的截锥体看起来像这样（红色箭头是光线方向，但现在忽略它）：</li></ol><p><img src="/2024/01/16/cascade-shadow-mapping/frustum2.png"></p><p>为了从世界空间转换到视图空间，我们将世界位置向量乘以视图矩阵（基于相机位置和旋转）。这意味着，如果我们已经有了视图空间中级联的坐标，我们必须将它们乘以视图矩阵的逆矩阵，以便将它们转换到世界空间：</p><p><img src="/2024/01/16/cascade-shadow-mapping/calc3.png"></p><ol start="3"><li>通过世界空间中的视锥体坐标，我们现在可以像任何其他对象一样将它们转换为光空间。请记住，光空间与视图空间完全相同，但我们使用光源代替相机。由于我们处理的是没有原点的定向光，因此我们只需要旋转世界，使光方向与正 Z 轴对齐。光的原点可以简单地是光空间坐标系的原点（这意味着我们不需要任何平移）。如果我们使用上图（红色箭头是光方向）来做到这一点，光空间中的级联平截头体应该如下所示：</li></ol><p><img src="/2024/01/16/cascade-shadow-mapping/frustum2.png"></p><ol start="4"><li>对于最终在光空间中的级联坐标，我们只需要通过获取八个坐标的 X&#x2F;Y&#x2F;Z 分量的最小&#x2F;最大值来为其生成一个边界框。该边界框提供正交投影的值，用于将此级联渲染到其阴影贴图中。通过分别为每个级联生成正交投影，我们现在可以将每个级联渲染为不同的阴影贴图。在光照阶段，我们将通过根据距观察者的距离选择阴影贴图来计算阴影系数。</li></ol>]]></content>
    
    
    <categories>
      
      <category>render</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shadow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fullscreen_quad_rendering</title>
    <link href="/2023/05/16/fullscreen-quad-rendering/"/>
    <url>/2023/05/16/fullscreen-quad-rendering/</url>
    
    <content type="html"><![CDATA[<p>渲染全屏四边形（或填充整个屏幕的东西）是 3D 实时图形中的一项常见任务，因为许多效果依赖于在 [0..1] 范围内使用适当的 uv 坐标在整个屏幕上渲染纹理。这适用于后期处理（光照计算、ssao）、延迟着色或程序生成的输出。</p><p>渲染此类全屏四边形的最先进方法是设置包含顶点（可选纹理坐标）和索引的缓冲区，用于渲染由两个三角形组成的四边形，绑定这些缓冲区并将它们作为着色器的输入属性。虽然这在 OpenGL 中只需几行就可以完成，但vulkan需要设置大量属性。因此，无需使用缓冲区中的顶点（和索引）来渲染填充屏幕的内容，而是可以使用 gl_VertexIndex （请参阅GL_KHR_vulkan_GLSL  ）顶点输入变量（类似于 OpenGL gl_VertexID）在顶点着色器中轻松生成顶点和纹理坐标。虽然这有点简化，但它基本上保存了调用顶点着色器的当前顶点的索引。</p><p>我们将使用它来生成一个全屏三角形，其作用类似于全屏四边形。为什么是三角形？因为它只需要 3 次顶点着色器调用（而不是由两个三角形组成的四边形调用 6 次）。</p><p>生成的三角形将如下所示：<br><img src="/2023/05/16/fullscreen-quad-rendering/fullscreentriangle_clipped.png"></p><p>该三角形包含我们的整个屏幕以及 [0..1] 的整个 uv 范围，以便我们可以像普通的全屏四边形一样使用它来应用后期处理效果。由于 GPU 剪切了屏幕边界之外的所有内容，我们实际上得到了一个只需要 3 个顶点的四边形。而且由于裁剪是免费的，因此我们不会浪费带宽，因为三角形的裁剪部分（灰色部分）不会被采样。</p><h3 id="Vulkan-部分"><a href="#Vulkan-部分" class="headerlink" title="Vulkan 部分"></a>Vulkan 部分</h3><p>在 Vulkan 应用程序中使用它非常简单，并且由于我们不需要任何缓冲区，因此我们无需设置大量属性（包括描述符集和布局），将其添加到现有的 Vulkan 应用程序非常简单。</p><h3 id="图形管线"><a href="#图形管线" class="headerlink" title="图形管线"></a>图形管线</h3><p>VkPipeline的pVertexInputState成员指定顶点输入属性和顶点输入绑定。由于我们不将任何顶点传递给着色器，因此我们需要为不包含任何输入或属性绑定的全屏管道设置一个空顶点输入状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 伪代码">VkPipelineVertexInputStateCreateInfo emptyInputState;<br>emptyInputState.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;<br>emptyInputState.vertexAttributeDescriptionCount = 0;<br>emptyInputState.pVertexAttributeDescriptions = nullptr;<br>emptyInputState.vertexBindingDescriptionCount = 0;<br>emptyInputState.pVertexBindingDescriptions = nullptr;<br>...<br>pipelineCreateInfo.pVertexInputState = &amp;emptyInputState;<br>...<br>vkCreateGraphicsPipelines(device, pipelineCache, 1, &amp;pipelineCreateInfo;, nullptr, &amp;fullscreenPipeline;));<br></code></pre></td></tr></table></figure><h3 id="剔除"><a href="#剔除" class="headerlink" title="剔除"></a>剔除</h3><p>请注意，顶点按顺时针顺序排列（参见上图），因此如果您使用剔除，则需要考虑到这一点，例如以下管道设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 伪代码">rasterizationState.cullMode = VK_CULL_MODE_FRONT_BIT;<br>rasterizationState.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE;<br></code></pre></td></tr></table></figure><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>通过上述全屏管道的顶点输入状态设置，我们现在可以绘制某些内容，而无需像从缓冲区渲染几何图形时那样预先绑定顶点（和索引）缓冲区：</p><p>vkCmdBindPipeline(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, fullscreenPipeline);<br>vkCmdDraw(commandBuffer, 3, 1, 0, 0);<br>只需将管道与空顶点输入状态绑定，并发出顶点数为 3 的绘制命令（非索引）。如果您使用正确的管道，这不会生成任何验证层错误，即使存在（技术上） ）没有要实际渲染的顶点。</p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>有趣的部分是顶点着色器，它将根据 gl_VertexIndex 生成顶点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shader">#version 450 <br>...<br>layout (location = 0) out vec2 outUV;<br>... <br>void main() <br>&#123;<br>    outUV = vec2((gl_VertexIndex &lt;&lt; 1) &amp; 2, gl_VertexIndex &amp; 2);<br>    gl_Position = vec4(outUV * 2.0f + -1.0f, 0.0f, 1.0f);<br>&#125;<br></code></pre></td></tr></table></figure><p>该着色器不包含任何输入属性，并仅根据 gl_VertexIndex 生成位置和纹理坐标（传递给片段着色器），其中纹理坐标位于三角形可见部分的 [0..1] 范围内。</p>]]></content>
    
    
    <categories>
      
      <category>render</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vulkan</tag>
      
      <tag>skill</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>multithreaded_shading</title>
    <link href="/2023/01/26/multithreaded-shading/"/>
    <url>/2023/01/26/multithreaded-shading/</url>
    
    <content type="html"><![CDATA[<h2 id="Vulkan-视角下的多线程渲染"><a href="#Vulkan-视角下的多线程渲染" class="headerlink" title="Vulkan 视角下的多线程渲染"></a>Vulkan 视角下的多线程渲染</h2><p>首先我们需要从vulkan api的顶层框架上来看一下，它在哪些地方可以让我们并行。</p><p>Vulkan API的基本框架<br>Vulkan不同于Gles只有一个（不被API暴露出来的）单一链条的cmdbuffer处理，它最大的特点是允许多个、多种类型的cmdbuffer同时在多个设备和线程上被处理</p><p>上图可以看到vk拥有多个physical device（或gpu，当然也可以是支持的其他处理器），只要是同一个physical device group中的physical device，就可以联合起来一起来创建出一个device（就是你的app 实例），而每个physical device上又有多个queue，这些queue属于三种queuefamily（gfx，cs，translate），每个queuefamily Qn都可以创建一个command pool Pn，每个Pn又可以创建一些cmdbuffer，这些cmdbuffer可以独自被处理，独自被提交给Qn的任意一个queue上。cmdbuffer是vk显示暴露的数据结构，它是cpu同gpu传输信息的桥梁，cpu将渲染指令记录到cmdbuffer上，然后通过提交给queue交由gpu执行。在一个cmdbuffer内部又包含了renderpass，指令被记录在renderpass里面或外面，记录在renderpass里面的指令还可以被封装成次级cmdbuffer，即secondarycmdbuffer的形式被主cmdbuffer执行。。。</p><p>总的来说，vulkan里面有并行的GPU设备，并行的queue，并行的cmdbuffer。</p><p>那么哪些阶段可以被并行执行？</p><p>Cpu一侧有两个主要的可被并行处理的阶段：</p><ol><li>Cmdbuffer的Record：所有vkcmd***类型的API都可以认为在进行cmdbuffer的record。我们可以拆解出多个独立的cmdbuffer，由不同的RHI线程进行api调用。（这其实是一般游戏的主要瓶颈，即drawcall数量瓶颈）</li><li>Cmdbuffer的submit：不同的cmdbuffer可以被提交到各自单独的queue中。可以根据设备提供的queue的数量，创建多个queue，在不同的rhi线程中将不同的cmdbuffer submit到不同的queue。（在实际项目中submit占用的时间非常短，少于1ms，且多数情况一帧只需要提交1次，做这个优化性价比不高）</li><li>将cmdbuffer的record和submit并行，submit和record两个步骤又可以在不同线程执行，cmdbuffer在当前帧record，在下一帧submit。（同样因为submit不是瓶颈，且又需要延迟一帧渲染，性价比不高）</li><li>为Translate，Gfx，CS独立各自单独的queue和cmdbuffer，这样，图形drawcall，cs的dispatch，图形资源的准备这三种不同工作将在不同的线程上处理，减少drawcall被其他工作block的机会。（这个是有意义的，ue新版本有async compute shader，实际上就是使用了同gfx不同的cs queue，至于translate，则可以将很多非dc性质的api调用同dc的分离，提高dc的吞吐效率，这个在gles也可以模拟实现，可以见<a href="https://km.woa.com/group/24861/articles/show/489959%EF%BC%8C%E5%8F%AA%E4%B8%8D%E8%BF%87vk%E4%B8%8B%E5%8F%AF%E4%BB%A5%E5%BE%80%E4%B8%80%E4%B8%AA%E5%8D%95%E7%8B%AC%E7%9A%84queue%E5%8E%BB%E6%8F%90%E4%BA%A4%E3%80%82%EF%BC%89">https://km.woa.com/group/24861/articles/show/489959，只不过vk下可以往一个单独的queue去提交。）</a></li></ol><p>本文主要讨论cmdbuffer的并行record，他用来解决大量drawcall的api瓶颈。<br>结构如下，我们在多个线程调用api填充cmdbuffer，全部cmdbuffer准备好后从一个线程进行最终的submit。</p><h3 id="并行粒度"><a href="#并行粒度" class="headerlink" title="并行粒度"></a>并行粒度</h3><p>讨论这个问题前我们需要了解vulkan API的一些设计限制。Vulkan有如下的API规范：</p><p>一个renderpass必须被包含在同一个cmdbuffer中 （即renderpass不能跨越cmdbuffer）</p><p>这意味着我们不能将一个renderpass中的drawcall拆分到多个cmdbuffer中，而移动端游戏为了带宽的最小化，都是尽量减少合并renderpass的，既然这样是不是意味着在控制带宽（renderpass数量）和并行drawcall之间难以兼得？</p><p>不是的，vulkan考虑了这个问题，并引入secondarycommandbuffer的概念来解决这个问题，下面会详细讲述。</p><p>我们的设计支持两种类型的并行。</p><ol><li>整个pass级别的并行（本文称为Async Pass）<br>每个cmdbuffer里面封装1个或几个renderpass，renderpass完整的嵌入在一个cmdbuffer里面。如下图，每个thread上的cmdbuffer上有完整的renderpass，每个renderpass并行的调用API。因为renderpass之间相互隔离，它的实现最为简单，每个thread上就是正常的启动，结束一个pass和drawcall。</li></ol><p>但是当一个renderpass里面的drawcall太多时，我们就必须实现drawcall级别的并行了。</p><ol start="2"><li>支持draw call级别的并行（本文称为Async Drawcall）</li></ol><p>正如前面提到的vulkan API限制renderpass不能跨越cmdbuffer，所以需要依靠secondary command buffer支持。</p><p>Secondary command buffer是中特殊的command buffer：</p><p>它内部不能执行renderpass相关的操作，只能执行drawcall相关的API。<br>它不能直接submmit给queue，只能被正常的command buffer（或称为primary command buffer）通过vkexecutecmdbuffer的形式执行<br>Vkexecutecmdbuffer必须在该primary commandbuffer结束记录状态前（vkendcommandbuffer）执行<br>这种级别的并行实现上就显得比较复杂，如下图，对thread1上的renderpass中的300个drawcall进行等分拆分到3个线程上。1.1-1.3的线程上都使用的secondary cmd buffer，他们填充好后，交给1线程的primary cmdbuffer execute，最后1线程才能执行endcmdbuffer。</p><p>但是这是不是说1线程要依赖1.1-1.3三个线程执行完才能继续下去？为了解决这个问题，可以在1线程上创建多个primary cmdbuffer，只有内嵌了secondary cmd buffer的那个primary cmdbuffer才需要等待，每当1线程上的一个primary cmd buffer (n)需要内嵌secondary cmd buffer时，就再重新开辟一个新的primary cmd buffer (n+1)即可，这样1线程上后续的dc在primary cmd buffer (n+1)上记录，primary cmd buffer (n)则负责等待它的所有secondary thread完成再end，我们最终在提交的时候只要保证在提交列表中primary cmd buffer (n)在primary cmd buffer (n+1)之前即可保证渲染顺序。</p><p>基于secondary cmdbuffer，可以将drawcall的并行拆到最细，理论上所有的drawcall都可以并行，只需要在最终submit之前保证所有thread的工作完成即可。</p><h2 id="UE4现有的多线程渲染框架与改造目标"><a href="#UE4现有的多线程渲染框架与改造目标" class="headerlink" title="UE4现有的多线程渲染框架与改造目标"></a>UE4现有的多线程渲染框架与改造目标</h2><p>现有的UE4多线程渲染框架<br>逻辑，渲染指令生成和API调用三大任务分开</p><p>项目引擎之前在UE4现有版本加入了auxiliary rhi机制<br>将资源生成类型的任务放到一个单独的rhi线程，允许与小核，减少资源准备类api对drawcall 类api的block</p><p>现在新的目标是，在vulkan下将drawcall类API并行处理：<br>依然保留主rhi（main rhi thread），用来进行那些不适合拆分到子线程的api以及做最终的submit和present。<br>对于相对独立，无法前后复用的pass，做并行的async render pass处理<br>对于其他pass，如果体量较大，将其中的部分分拆出来做async draw call 处理<br>为了能够异步的填充rhi command，每个rhi thread也要对应一个单独的render thread，即render thread 本身也被拆开并行<br>移动端对于线程数目的考量：<br>我们常说对于移动端不要肆意的使用多线程优化，因为最好的android设备也就4个大核，所以前面我们描绘的架构虽然可以让你拥有无限多的线程，任意分拆drawcall，但那是脱离实际的完美情况。</p><p>因为考虑到已经存在的game，main render，main rhi3个大线程，所以最终我们手机上实际上只会增多一个异步的rhi线程（本文称task rhi thread）和一个异步的render 线程（本文称task render thread），更多的异步线程数量测试上都会导致效率变差。也就是说我们其实只是给原有单链条的渲染API增加了一条新路，变成两条而已。</p><p>最终版本移动端的vulkan多线程渲染框架如下</p><p>在上图中，实时的csm shadow作为async pass放在了task上（因为他永远是单独的pass，是的因为drawcall变的廉价，甚至可以尝试不用csm shadow cache～），而static mesh部分因为原本就有可能同其他部分共用pass而被作为async drawcall放在task上。</p><p>3 render thread 和rhi thread改造的更多细节<br>vk的secondary command buffer相关机制支持：<br>secondary command buffer的创建：和primary 不一样，创建时需要一个特殊的flag，需要为它维护一个单独的cmdbuffer pool</p><p>secondary command buffer的begin，这里涉及到vulkan的如下设计规范：</p><p>secondary cmdbuffer在begin的时候就要传入它所被嵌入的renderpass</p><p>和primary cmdbuffer不一样的是，secondary cmd buffer在begin的时候需要指定它所在的renderpass，这意味着虽然primary和secondary是在各自独立的线程记录，但是renderpass这个信息是api record的时候唯一必备的外部信息（事实上文档上说如果能提供primary的framebuffer则更有利于优化，不提供也可），而在目前ue的框架下，renderpass是有可能在primary的cmd beginrenderpass时才创建的，所以secondary cmd buffer的执行至少要在primary command buffer的begin pass 执行之后执行，这是一个同步点。但是如果我们有了rendergraph之类的，能够在一帧开始前就先验的知道这帧要用到的所有renderpass，这里面就不需要这个等待了。</p><p>此外Secondary command buffer begin的时候还需要设置begin flag为renderpass_continue_bit,(表示它作为一个secondary buffer，完全在另一个cmdbuffer的pass内执行</p><p>secondary command buffer内部的渲染状态，这里涉及到vulkan的如下设计规范：<br>secondary cmdbuffer内部不能感知包含它的primarycmdbuffer的渲染状态</p><p>vulkan并没有在官方文档很明显的地方提到这个问题，只在一些角落暗示过，实际上它意味着你在primary cmdbuffer级别里面设置的各种渲染状态，如shader，stencil什么的，对于它里面包含的secondary cmdbuffer是无效的，你必须在secondary cmdbuffer里面重新设置过。</p><p>  这要求你在record一个secondary cmd buffer的时候要能在程序中获取到它所处的primary 的一些外部渲染环境，设置进去，在程序实现的时候这可能是要特别小心的。</p><p>需要灵活支持一个 renderpass是subpass_content_secondary还是subpass_content_inline状态，这是非常麻烦的一个改造。这里又涉及到vulkan的一个设计规范：<br>Vulkan的renderpass在一个subpass之内只能处于以下两种模式之一：要么里面完全只能执行secondary cmdbuffer（所有非vkexecutesecondary的api皆为非法），要么里面完全不能执行secondary cmd buffer。</p><p>看下面的这个图，第一种情况是ok的，subpass之内都是统一的内容状态，但是第二种是不行的，因为它杂糅了普通drawcall和secondaryexecute </p><p>这是非常麻烦的一个点，为什么这样说？</p><p>通常我们移动端游戏为了减少render pass的切换，需要尽量复用一个renderpass，而一个大的renderpass它可能只是部分drawcall需要被拆出来到task rhi上异步执行，那就不可避免的出现这种“杂糅”状况。</p><p>为了解决这种杂糅，一种是如上图第一种形式插入更多的nextsubpass，用subpass做篱笆将不同种类分开，但是这是有损gpu性能的，我们不能确定硬件在切subpass的时候对于相同的rt情况下是否有优化，有可能将产生rt内容的load&#x2F;store。另一种是如下图所示，只要一个renderpass中有任何一个drawcall被拆出来放到taskrhi上，那么整个renderpass的所有drawcall都需要被拆成secondary cmd buffer的形式在，只是说有个secondary cmd buffer在task上异步填充，有的依然在当前primary的main rhi上填充。</p><p>从上面这个图能够看出来，pass内部全都是vkexecutesecondary了，注意这里不意味着secondary4 要等待异步线程吧secondary 2和3处理完，他们依然是并行的，你只需要记住在4前面还有个2和3，只需要在最终submmit的之前end这个pass，在endpass的时候按照1 2 3 4的顺序执行这个execute就可以的。</p><pre><code class="hljs">  带有async drawcall的renderpass的end</code></pre><p>对于内嵌了secondary的renderpass在end的时候有个新的问题，因为executesecondary必须要发生在endpass之前，而mainrhi想endpass的时候task rhi可能还没有执行完，这会导致asyn rhi对main rhi的阻塞，因为main rhi还有后续的renderpass要begin。</p><p>一种解决方案是，此时重新begin一个新的primary cmd buffer，用于begin后续的renderpass，而之前的那个primary cmd buffer会等待它的secondary都执行完。这意味着我们的设计思路是：所有的renderpass都会延迟到最终submmit之前才进行帧的endpass（endpass前要按顺序execute secondary），每当一个renderpass被要求endpass的时候，如果他内含secondary，就马上启动一个新的的primary cmd buffer记录后续renderpass。</p><p>如上面图所示endpass只是加了一个mark，后面会开启新的primary cmd buffer，我们知道一次submit的时候可以submit多个primay cmd buffer，你只需要保证他们在submitinfo中的列表顺序就能保证他们的渲染顺序。</p><p>这样原本ue4中submmit的一个单一的primary cmd buffer可能被碎解成多个，因此vkcmdbuffer的结构也需要做些改造，里面增加了previous cmd buffer的数组，此外因为primary cmdbuffer还可能包含一些secondary cmd buffer，所以还增加了一个children 数组。</p><p>改造后的结构是如下：</p><p>Primary Cmd buffer的Submmit提交，提交是最终的一步操作，也是整个结构唯一需要同步等待所有线程工作完成的地方，在main rhi上对于每个primary cmd buffer，依次调用vkexecutecmdbuffer执行它的每个secondary cmd buffer（这个执行顺序很重要，它就是gpu的处理顺序），再执行相应的nextsubpass，endpass，endcmdbuffer这操作，当然primary cmdbuffer要按照渲染顺序放入submitinfo中。<br>Thread-safe<br>首先考虑到任何renderthread上的逻辑都有可能被在异步执行，所以一些不thread-safe的渲染线程代码都要改造，例如去掉一些单例的使用。</p><p>Task render和main Render 之间的关系<br>在每帧render结束前，main render会等待task render执行完毕，所以要合适的分配main 和task的任务，尽量让main的工作量稍多一些。</p><p>4 其他问题<br>负载均衡<br>我们需要很好的平衡main 和task 两个渲染线程间的任务量，让main的任务稍多与task一点点，最好的方式是基于frame graph预先知道当前帧需要绘制哪些东西，才能做到最佳的负载均衡</p><p>GPU负载同HSR失效</p><p>我们发现在一些Adreno设备上，当使用secondary command buffer进行多线程提交时，gpu时间会大大增长，很像是硬件的深度筛选（即adreno的LRZ技术）失效，导致了更多的overdraw。</p><p>通过翻阅官方文档，确实找到了官方的说法，在文档<a href="https://blogs.igalia.com/dpiliaiev/adreno-lrz/%E5%92%8Chttps://developer.qualcomm.com/sites/default/files/docs/adreno-gpu/developer-guide/gpu/overview.html#lrz%E4%B8%AD%E9%83%BD%E6%9C%89%E6%98%8E%E7%A1%AE%E6%8F%90%E5%88%B0%EF%BC%9A">https://blogs.igalia.com/dpiliaiev/adreno-lrz/和https://developer.qualcomm.com/sites/default/files/docs/adreno-gpu/developer-guide/gpu/overview.html#lrz中都有明确提到：</a></p><p>在sdp 855及以下的设备上，因为lrz机制基于的ztest方向跟踪是在cpu一侧做的，并行的api提交会让他紊乱，这样会导致lrz失效，进而gpu不能准确找到每个pixel最靠前的primitive进行渲染，出现更多的overdraw。而865以后因为在gpu上进行跟踪，所以解决了这个问题。但是我们的实际测试数据发现一些865 870的设备依然存在这个问题，保险起见，secondary cmd buffer只能运行在888及以上的设备上，这真的是一个令人悲伤的事情，说明硬件的发展还没有很好的为vulkan做好优化啊。</p><p>但是好消息是mali的所有设备不存在这个问题！～～</p><p>5 性能分析</p><p>从android的trace上可以看到有两条并行提交的队列，相比只有一条提交队列，总的渲染的cpu耗时被大大缩减，在我们项目中大部分情况下rhi线程的时间被缩短30%左右，有意思的一点是在大部分设备上，gpu的耗时也略微减少，目前还不能很好的解释。</p><p>6.结语<br>Vulkan作为现代的图形API，有着更加强大复杂的特性，同gles相比，更像是C++对比lua，它可以使我们从更底层的视角去看待图形编程，自己掌握多线程，内存分配，同步等，我们就不能像应用古老的gles一样去搭建渲染框架，那样就只是用着vulkan的皮囊而没有发挥它真正的威力，不过这对编程人员是没有那么友好的，且移动端的前人经验不多，就需要深入分析vulkan的文档，多尝试，另外vulkan作为一个追求性能的api，不太在api层次做校验，这导致对api的调用极易引起gpu的device lost，必须擅用它的validation layer及时发现潜在的问题。</p>]]></content>
    
    
    <categories>
      
      <category>render</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vulkan</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clustered_forward_shading</title>
    <link href="/2022/01/15/clustered_forward_shading/"/>
    <url>/2022/01/15/clustered_forward_shading/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>cluster shading是将相机的Frustum按x y z切块成cluster，记录每个cluster 受哪些实时光源影响，再对有效的cluster进行光照计算。<br><img src="/2022/01/15/clustered_forward_shading/frustum.png" alt="doom"></p><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>解决tbdr和观察物体有强关联，在深度不连续的地方，会导致开销增大的问题。file:&#x2F;&#x2F;&#x2F;home&#x2F;berg&#x2F;code&#x2F;junglemanpro&#x2F;source&#x2F;_posts&#x2F;deferred-shading.md</p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><ol><li>pre depth,只渲染不透明物体</li><li>计算保存 有效的cluster</li><li>根据lighting(pos,range)计算得到lighting bounds,并根据lighting bounds得到每个cluster命中的lighting count</li><li>遍历所有cluster的lighting count,累加至lighting total,并记录每个cluster在lighting total累加时的总量，记作offset</li><li>遍历所有lighting,根据lighting bounds遍历其中的有效cluster,累加当前cluster count和总的offset将light index记录在light list中</li><li>根据offset和lighting count读取cluster光照信息进行光照计算</li></ol><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><ol><li><p>pre depth 此为优化项，搭配ssao msaa食用更美味。</p></li><li><p>计算保存 有效的cluster</p><ul><li>点位： 世界坐标系 转换到 相机坐标系 ，由相机坐标系 点位 得到深度信息</li></ul><p> vec4 view_pos &#x3D; ubo_in.view * world_pos_in;</p><ul><li>将frag_pos.xy view_pos.z转换得到当前点位的分簇 x y z坐标</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs FUNC">uvec3 view_pos_to_grid_coord(vec2 frag_pos, float view_z)<br>&#123;<br>    vec3 c;<br>    c.xy = (frag_pos-0.5f) / ubo_in.tile_size;<br>    c.z = min(float(GRID_DIM_Z - 1), max(0.f, float(GRID_DIM_Z) * log((-view_z -   CAM_NEAR) / (ubo_in.cam_far - CAM_NEAR) + 1.f)));<br>    return uvec3(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将当前fragpos的分簇 x y z坐标转化为cluster id <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs FUNC">uint grid_coord_to_grid_idx(uvec3 c)<br>&#123;<br>    return ubo_in.grid_dim.x * ubo_in.grid_dim.y * c.z + ubo_in.grid_dim.x * c.y + c.x;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p> 保存 有效的cluster<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs FUNC">imageStore(grid_flags, int(grid_idx), uvec4(1, 0, 0, 0));<br></code></pre></td></tr></table></figure><br> <img src="/2022/01/15/clustered_forward_shading/cluster_flags.png" alt="记录有效的cluster"></p><ul><li>tips: gl_FragCoord<br> 当viewport 范围 为（0，0，800，600）时， x, y 的取值范围为（0.5, 0.5, 799.5, 599.5）</li></ul></li><li><p>计算lighting bounds和cluster命中的lighting count</p><ul><li>将light pos转化到相机坐标系，根据light range的到最小值和最大值，剔除不在该camera frustum下的lighting,将有效的light pos转化为frag</li><li>grid_light_counts 累加每一个cluster对应的count</li></ul></li><li><p>记录每个cluster在lighting list中的offset<br> numgroup x y z 设置每个group的size为16<br><img src="/2022/01/15/clustered_forward_shading/compute_offset.png" alt="compute_shader对应的线程组"></p></li><li><p>生成光照列表<br>遍历light bounds, 读取有效的cluster的偏移量,<br><img src="/2022/01/15/clustered_forward_shading/lighting_list.png"></p></li></ol><h3 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h3><ul><li>资源类型：访问具有空间连续性，使用buffer和贴图有更好的cache命中率。随机访问的特性更强使用ubo减少访问贴图采样次数，如light vec。</li><li>贴图格式：根据实际需求，使用最小的texture格式减少带宽，如uvec2使用uint r16b16或者uint r8b8等。</li><li>是否带阴影的灯光 在第一张表格中进行区分？如果在光源信息中标识是否带阴影会在shader中多引入动态分支，而在第一张表格中区分可以省去此动态分支，但是需要更大的带宽，需要衡量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>render</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lighting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>forward_plus_shading</title>
    <link href="/2022/01/15/forward-plus-shading/"/>
    <url>/2022/01/15/forward-plus-shading/</url>
    
    <content type="html"><![CDATA[<h3 id="Tiled-based-Deferred-Shading"><a href="#Tiled-based-Deferred-Shading" class="headerlink" title="Tiled-based Deferred Shading"></a>Tiled-based Deferred Shading</h3><p>在进入正题之前，我们先回顾一下Intel在SIGGRAPH Courses 2010里提到的Tiled-based Deferred Shading。它的算法框架是：</p><ol><li>生成G-Buffer，这一步和传统deferred shading一样。</li><li>把G-Buffer划分成许多16×16的tile，每个tile根据depth得到bounding box。</li><li>对于每个tile，把它的bounding box和light求交，得到对这个tile有贡献的light序列。</li><li>对于G-Buffer的每个pixel，用它所在tile的light序列累加计算shading。</li></ol><p>在原先的deferred框架下，每个light需要画一个light volume，以决定它会影响到哪些pixel（也就是light culling）。而用tiled based的方法，只需要一个pass就可以对所有的光源进行求交。如果用了AMD在Mecha demo中用到的OIT方法，还可以做一个per-tile linked list，直接把light序列存在链表里。</p><h3 id="Forward-Rendering"><a href="#Forward-Rendering" class="headerlink" title="Forward+ Rendering"></a>Forward+ Rendering</h3><p>有了Tiled-based Deferred Shading的基础，理解Forward+就变得简单多了。Forward+ Shading-based Deferred Shading的关系就好比原先的Forward Shading和Deferred Shading，所以我们可以照猫画虎一次：</p><ol><li>Z-prepass，很多forward shading都会用这个作为优化，而在forward+中，这个变成了必然步骤。</li><li>把Z-Buffer划分成许多16×16的tile，每个tile根据depth得到bounding box。</li><li>对于每个tile，把它的bounding box和light求交，得到对这个tile有贡献的light序列。</li><li>对于每个物体，在PS中用该pixel所在tile的light序列累加计算shading。</li></ol><p>从这里可以看出，前两步与Tiled-based deferred shading大同小异，但只需要Z-Buffer，而不需要很消耗带宽的G-Buffer（G-Buffer最小也要32bit color + 32bit depth）。第三步是完全一样的。第四部由于用了forward，可以有forward的各种好处：</p><ul><li>复杂材质</li><li>支持硬件AA（虽然我一直认为硬件AA多算了很多东西，是一种巨大的浪费）</li><li>带宽利用率高</li><li>支持透明物体</li></ul><p>由于light已经在步骤3中cache了，所以也可以不像传统的forward那样，把材质和光源搅在一起。加上shader中动态分支的能力，不难实现类似deferred那样的巨量光源支持。由于带宽省了很多，Forward+的速度能比Deferred快。在原paper里的性能比较足以说明这个问题。</p><p><img src="/2022/01/15/forward-plus-shading/Forward+VSDeferred.png" alt="d"></p><p>透明物体的渲染。第一步生成Z-prepass的时候，可以采用双Z-Buffer的办法，一个放不透明物体的Z，另一个放透明物体的Z。在第二步计算tile bounding box的时候，不管透不透明都放在一起计算一个总的bounding box。后面步骤不变，就能原生支持透明物体。</p><p>由于有了Z-Buffer，其他原先对Deferred有利的效果，比如GI、SSR，都可以直接应用。SSAO、SSVO之类的方法，如果需要考虑pixel normal，就需要适当的修改才能应用上。</p>]]></content>
    
    
    <categories>
      
      <category>render</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lighting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>deferred_shading</title>
    <link href="/2021/05/20/deferred-shading/"/>
    <url>/2021/05/20/deferred-shading/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>正向渲染下，是否丢弃某片元的操作是在各种测试之后，如果在frag阶段做大量算法（如光照计算），而后进行的测试将该片元舍弃，等于做了无用功。当光照数量可观时，严重消耗了算力。<br>而延迟渲染下，先渲染场景一次，记录有效的 位置向量(Position Vector)、颜色向量(Color Vector)、法向量(Normal Vector)和&#x2F;或镜面值(Specular Value)，这时候的片段信息都是作为最顶层的片段，保证了对于在光照处理阶段中处理的每一个像素都只处理一次，再使用G缓冲中的几何数据对每一个片段计算场景的光照。</p><p><img src="/2021/05/20/deferred-shading/deferred_g_buffer.png" alt="d"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>缺点：不能渲染透明物体 gbuffer需要大量带宽</p><h3 id="vulkan实践"><a href="#vulkan实践" class="headerlink" title="vulkan实践"></a>vulkan实践</h3><ul><li>vulkan实现延迟渲染的方法<ol><li>多pass,一个gbuffer pass生成gbuffer,一个pass处理光照计算，中间使用semaphores同步，需要submit两次</li><li>subpass,使用一个pass内嵌两个subpass</li></ol></li></ul><h2 id="G缓冲"><a href="#G缓冲" class="headerlink" title="G缓冲"></a>G缓冲</h2><p>G缓冲(G-buffer)是对所有用来储存光照相关的数据，并在最后的光照处理阶段中使用的所有纹理的总称。趁此机会，让我们顺便复习一下在正向渲染中照亮一个片段所需要的所有数据：</p><p>一个3D位置向量来计算(插值)片段位置变量供lightDir和viewDir使用<br>一个RGB漫反射颜色向量，也就是反照率(Albedo)<br>一个3D法向量来判断平面的斜率<br>一个镜面强度(Specular Intensity)浮点值<br>所有光源的位置和颜色向量<br>玩家或者观察者的位置向量<br>有了这些(逐片段)变量的处置权，我们就能够计算我们很熟悉的(布林-)冯氏光照(Blinn-Phong Lighting)了。光源的位置，颜色，和玩家的观察位置可以通过uniform变量来设置，但是其它变量对于每个对象的片段都是不同的。如果我们能以某种方式传输完全相同的数据到最终的延迟光照处理阶段中，我们就能计算与之前相同的光照效果了，尽管我们只是在渲染一个2D方形的片段。</p><p>OpenGL并没有限制我们能在纹理中能存储的东西，所以现在你应该清楚在一个或多个屏幕大小的纹理中储存所有逐片段数据并在之后光照处理阶段中使用的可行性了。因为G缓冲纹理将会和光照处理阶段中的2D方形一样大，我们会获得和正向渲染设置完全一样的片段数据，但在光照处理阶段这里是一对一映射。</p><p>整个过程在伪代码中会是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs 伪代码">while(...) // 游戏循环<br>&#123;<br>    // 1. 几何处理阶段：渲染所有的几何/颜色数据到G缓冲 <br>    glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);<br>    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>    gBufferShader.Use();<br>    for(Object obj : Objects)<br>    &#123;<br>        ConfigureShaderTransformsAndUniforms();<br>        obj.Draw();<br>    &#125;  <br>    // 2. 光照处理阶段：使用G缓冲计算场景的光照<br>    glBindFramebuffer(GL_FRAMEBUFFER, 0);<br>    glClear(GL_COLOR_BUFFER_BIT);<br>    lightingPassShader.Use();<br>    BindAllGBufferTextures();<br>    SetLightingUniforms();<br>    RenderQuad();<br>&#125;<br></code></pre></td></tr></table></figure><p>对于每一个片段我们需要储存的数据有：一个位置向量、一个法向量，一个颜色向量，一个镜面强度值。所以我们在几何处理阶段中需要渲染场景中所有的对象并储存这些数据分量到G缓冲中。我们可以再次使用多渲染目标(Multiple Render Targets)来在一个渲染处理之内渲染多个颜色缓冲，在之前的泛光教程中我们也简单地提及了它。</p><p>对于几何渲染处理阶段，我们首先需要初始化一个帧缓冲对象，我们很直观的称它为gBuffer，它包含了多个颜色缓冲和一个单独的深度渲染缓冲对象(Depth Renderbuffer Object)。对于位置和法向量的纹理，我们希望使用高精度的纹理(每分量16或32位的浮点数)，而对于反照率和镜面值，使用默认的纹理(每分量8位浮点数)就够了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs 伪代码"><br>GLuint gBuffer;<br>glGenFramebuffers(1, &amp;gBuffer);<br>glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);<br>GLuint gPosition, gNormal, gColorSpec;<br><br>// - 位置颜色缓冲<br>glGenTextures(1, &amp;gPosition);<br>glBindTexture(GL_TEXTURE_2D, gPosition);<br>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, gPosition, 0)<br><br>// - 法线颜色缓冲<br>glGenTextures(1, &amp;gNormal);<br>glBindTexture(GL_TEXTURE_2D, gNormal);<br>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, gNormal, 0);<br><br>// - 颜色 + 镜面颜色缓冲<br>glGenTextures(1, &amp;gAlbedoSpec);<br>glBindTexture(GL_TEXTURE_2D, gAlbedoSpec);<br>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, gAlbedoSpec, 0);<br><br>// - 告诉OpenGL我们将要使用(帧缓冲的)哪种颜色附件来进行渲染<br>GLuint attachments[3] = &#123; GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2 &#125;;<br>glDrawBuffers(3, attachments);<br><br>// 之后同样添加渲染缓冲对象(Render Buffer Object)为深度缓冲(Depth Buffer)，并检查完整性<br>[...]<br><br></code></pre></td></tr></table></figure><p>由于我们使用了多渲染目标，我们需要显式告诉OpenGL我们需要使用glDrawBuffers渲染的是和GBuffer关联的哪个颜色缓冲。同样需要注意的是，我们使用RGB纹理来储存位置和法线的数据，因为每个对象只有三个分量；但是我们将颜色和镜面强度数据合并到一起，存储到一个单独的RGBA纹理里面，这样我们就不需要声明一个额外的颜色缓冲纹理了。随着你的延迟渲染管线变得越来越复杂，需要更多的数据的时候，你就会很快发现新的方式来组合数据到一个单独的纹理当中。</p><p>接下来我们需要渲染它们到G缓冲中。假设每个对象都有漫反射，一个法线和一个镜面强度纹理，我们会想使用一些像下面这个片段着色器的东西来渲染它们到G缓冲中去。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> gPosition;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> gNormal;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> gAlbedoSpec;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> FragPos;<br><span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> Normal;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture_diffuse1;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texture_specular1;<br><br><span class="hljs-type">void</span> main()<br>&#123;    <br>    <span class="hljs-comment">// 存储第一个G缓冲纹理中的片段位置向量</span><br>    gPosition = FragPos;<br>    <span class="hljs-comment">// 同样存储对每个逐片段法线到G缓冲中</span><br>    gNormal = <span class="hljs-built_in">normalize</span>(Normal);<br>    <span class="hljs-comment">// 和漫反射对每个逐片段颜色</span><br>    gAlbedoSpec.rgb = <span class="hljs-built_in">texture</span>(texture_diffuse1, TexCoords).rgb;<br>    <span class="hljs-comment">// 存储镜面强度到gAlbedoSpec的alpha分量</span><br>    gAlbedoSpec.a = <span class="hljs-built_in">texture</span>(texture_specular1, TexCoords).r;<br>&#125;  <br></code></pre></td></tr></table></figure><p>因为我们使用了多渲染目标，这个布局指示符(Layout Specifier)告诉了OpenGL我们需要渲染到当前的活跃帧缓冲中的哪一个颜色缓冲。注意我们并没有储存镜面强度到一个单独的颜色缓冲纹理中，因为我们可以储存它单独的浮点值到其它颜色缓冲纹理的alpha分量中。</p><p>如果我们现在想要渲染一大堆纳米装战士对象到gBuffer帧缓冲中，并通过一个一个分别投影它的颜色缓冲到铺屏四边形中尝试将他们显示出来，我们会看到向下面这样的东西：</p><p>尝试想象世界空间位置和法向量都是正确的。比如说，指向右侧的法向量将会被更多地对齐到红色上，从场景原点指向右侧的位置矢量也同样是这样。一旦你对G缓冲中的内容满意了，我们就该进入到下一步：光照处理阶段了。</p><p>##延迟光照处理阶段</p><p>现在我们已经有了一大堆的片段数据储存在G缓冲中供我们处置，我们可以选择通过一个像素一个像素地遍历各个G缓冲纹理，并将储存在它们里面的内容作为光照算法的输入，来完全计算场景最终的光照颜色。由于所有的G缓冲纹理都代表的是最终变换的片段值，我们只需要对每一个像素执行一次昂贵的光照运算就行了。这使得延迟光照非常高效，特别是在需要调用大量重型片段着色器的复杂场景中。</p><p>对于这个光照处理阶段，我们将会渲染一个2D全屏的方形(有一点像后期处理效果)并且在每个像素上运行一个昂贵的光照片段着色器。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>shaderLightingPass<span class="hljs-selector-class">.Use</span>();<br><span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE0);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, gPosition);<br><span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE1);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, gNormal);<br><span class="hljs-built_in">glActiveTexture</span>(GL_TEXTURE2);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D, gAlbedoSpec);<br><span class="hljs-comment">// 同样发送光照相关的uniform</span><br><span class="hljs-built_in">SendAllLightUniformsToShader</span>(shaderLightingPass);<br><span class="hljs-built_in">glUniform3fv</span>(glGetUniformLocation(shaderLightingPass.Program, &quot;viewPos&quot;), <span class="hljs-number">1</span>, &amp;camera<span class="hljs-selector-class">.Position</span><span class="hljs-selector-attr">[0]</span>);<br><span class="hljs-built_in">RenderQuad</span>();  <br><br></code></pre></td></tr></table></figure><p>我们在渲染之前绑定了G缓冲中所有相关的纹理，并且发送光照相关的uniform变量到着色器中。</p><p>光照处理阶段的片段着色器和我们之前一直在用的光照教程着色器是非常相似的，除了我们添加了一个新的方法，从而使我们能够获取光照的输入变量，当然这些变量我们会从G缓冲中直接采样。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> gPosition;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> gNormal;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> gAlbedoSpec;<br><br>struct Light &#123;<br>    <span class="hljs-type">vec3</span> Position;<br>    <span class="hljs-type">vec3</span> Color;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-type">int</span> NR_LIGHTS = <span class="hljs-number">32</span>;<br><span class="hljs-keyword">uniform</span> Light lights[NR_LIGHTS];<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> viewPos;<br><br><span class="hljs-type">void</span> main()<br>&#123;             <br>    <span class="hljs-comment">// 从G缓冲中获取数据</span><br>    <span class="hljs-type">vec3</span> FragPos = <span class="hljs-built_in">texture</span>(gPosition, TexCoords).rgb;<br>    <span class="hljs-type">vec3</span> Normal = <span class="hljs-built_in">texture</span>(gNormal, TexCoords).rgb;<br>    <span class="hljs-type">vec3</span> Albedo = <span class="hljs-built_in">texture</span>(gAlbedoSpec, TexCoords).rgb;<br>    <span class="hljs-type">float</span> Specular = <span class="hljs-built_in">texture</span>(gAlbedoSpec, TexCoords).a;<br><br>    <span class="hljs-comment">// 然后和往常一样地计算光照</span><br>    <span class="hljs-type">vec3</span> lighting = Albedo * <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 硬编码环境光照分量</span><br>    <span class="hljs-type">vec3</span> viewDir = <span class="hljs-built_in">normalize</span>(viewPos - FragPos);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NR_LIGHTS; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 漫反射</span><br>        <span class="hljs-type">vec3</span> lightDir = <span class="hljs-built_in">normalize</span>(lights[i].Position - FragPos);<br>        <span class="hljs-type">vec3</span> diffuse = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(Normal, lightDir), <span class="hljs-number">0.0</span>) * Albedo * lights[i].Color;<br>        lighting += diffuse;<br>    &#125;<br><br>    FragColor = <span class="hljs-type">vec4</span>(lighting, <span class="hljs-number">1.0</span>);<br>&#125;  <br></code></pre></td></tr></table></figure><p>光照处理阶段着色器接受三个uniform纹理，代表G缓冲，它们包含了我们在几何处理阶段储存的所有数据。如果我们现在再使用当前片段的纹理坐标采样这些数据，我们将会获得和之前完全一样的片段值，这就像我们在直接渲染几何体。在片段着色器的一开始，我们通过一个简单的纹理查找从G缓冲纹理中获取了光照相关的变量。注意我们从gAlbedoSpec纹理中同时获取了Albedo颜色和Spqcular强度。</p><p>因为我们现在已经有了必要的逐片段变量(和相关的uniform变量)来计算布林-冯氏光照(Blinn-Phong Lighting)，我们不需要对光照代码做任何修改了。我们在延迟着色法中唯一需要改的就是获取光照输入变量的方法。</p><p>运行一个包含32个小光源的简单Demo会是像这样子的：</p><p><img src="/2021/05/20/deferred-shading/deferred_shading.png" alt="d"></p><p>你可以在以下位置找到Demo的完整源代码，和几何渲染阶段的顶点和片段着色器，还有光照渲染阶段的顶点和片段着色器。</p><p>延迟着色法的其中一个缺点就是它不能进行混合(Blending)，因为G缓冲中所有的数据都是从一个单独的片段中来的，而混合需要对多个片段的组合进行操作。延迟着色法另外一个缺点就是它迫使你对大部分场景的光照使用相同的光照算法，你可以通过包含更多关于材质的数据到G缓冲中来减轻这一缺点。</p><p>为了克服这些缺点(特别是混合)，我们通常分割我们的渲染器为两个部分：一个是延迟渲染的部分，另一个是专门为了混合或者其他不适合延迟渲染管线的着色器效果而设计的的正向渲染的部分。为了展示这是如何工作的，我们将会使用正向渲染器渲染光源为一个小立方体，因为光照立方体会需要一个特殊的着色器(会输出一个光照颜色)。</p><p>##结合延迟渲染与正向渲染</p><p>现在我们想要渲染每一个光源为一个3D立方体，并放置在光源的位置上随着延迟渲染器一起发出光源的颜色。很明显，我们需要做的第一件事就是在延迟渲染方形之上正向渲染所有的光源，它会在延迟渲染管线的最后进行。所以我们只需要像正常情况下渲染立方体，只是会在我们完成延迟渲染操作之后进行。代码会像这样：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">// 延迟渲染光照渲染阶段</span><br>[...]<br>RenderQuad();<br><br><span class="hljs-comment">// 现在像正常情况一样正向渲染所有光立方体</span><br>shaderLightBox.<span class="hljs-keyword">Use</span>();<br>glUniformMatrix4fv(locProjection, 1, GL_FALSE, <span class="hljs-keyword">glm</span>::value_ptr(projection));<br>glUniformMatrix4fv(locView, 1, GL_FALSE, <span class="hljs-keyword">glm</span>::value_ptr(<span class="hljs-keyword">view</span>));<br><span class="hljs-keyword">for</span> (GLuint i = 0; i &lt; lightPositions.size(); i++)<br>&#123;<br>    model = <span class="hljs-keyword">glm</span>::mat4();<br>    model = <span class="hljs-keyword">glm</span>::<span class="hljs-keyword">translate</span>(model, lightPositions[i]);<br>    model = <span class="hljs-keyword">glm</span>::scale(model, <span class="hljs-keyword">glm</span>::vec3(0.25f));<br>    glUniformMatrix4fv(locModel, 1, GL_FALSE, <span class="hljs-keyword">glm</span>::value_ptr(model));<br>    glUniform3fv(locLightcolor, 1, &amp;lightColors[i][0]);<br>    RenderCube();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然而，这些渲染出来的立方体并没有考虑到我们储存的延迟渲染器的几何深度(Depth)信息，并且结果是它被渲染在之前渲染过的物体之上，这并不是我们想要的结果。</p><p><img src="/2021/05/20/deferred-shading/deferred_lights_no_depth.png" alt="d"></p><p>我们需要做的就是首先复制出在几何渲染阶段中储存的深度信息，并输出到默认的帧缓冲的深度缓冲，然后我们才渲染光立方体。这样之后只有当它在之前渲染过的几何体上方的时候，光立方体的片段才会被渲染出来。我们可以使用glBlitFramebuffer复制一个帧缓冲的内容到另一个帧缓冲中，这个函数我们也在抗锯齿的教程中使用过，用来还原多重采样的帧缓冲。glBlitFramebuffer这个函数允许我们复制一个用户定义的帧缓冲区域到另一个用户定义的帧缓冲区域。</p><p>我们储存所有延迟渲染阶段中所有物体的深度信息在gBuffer这个FBO中。如果我们仅仅是简单复制它的深度缓冲内容到默认帧缓冲的深度缓冲中，那么光立方体就会像是场景中所有的几何体都是正向渲染出来的一样渲染出来。就像在抗锯齿教程中介绍的那样，我们需要指定一个帧缓冲为读帧缓冲(Read Framebuffer)，并且类似地指定一个帧缓冲为写帧缓冲(Write Framebuffer)：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">glBindFramebuffer</span>(GL_READ_FRAMEBUFFER, gBuffer);<br><span class="hljs-built_in">glBindFramebuffer</span>(GL_DRAW_FRAMEBUFFER, <span class="hljs-number">0</span>); <span class="hljs-comment">// 写入到默认帧缓冲</span><br><span class="hljs-built_in">glBlitFramebuffer</span>(<br>  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, GL_DEPTH_BUFFER_BIT, GL_NEAREST<br>);<br><span class="hljs-built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 现在像之前一样渲染光立方体</span><br><span class="hljs-selector-attr">[...]</span>  <br></code></pre></td></tr></table></figure><p>在这里我们复制整个读帧缓冲的深度缓冲信息到默认帧缓冲的深度缓冲，对于颜色缓冲和模板缓冲我们也可以这样处理。现在如果我们接下来再渲染光立方体，场景里的几何体将会看起来很真实了，而不只是简单地粘贴立方体到2D方形之上：</p><p><img src="/2021/05/20/deferred-shading/deferred_lights_depth.png" alt="d"></p><p>有了这种方法，我们就能够轻易地结合延迟着色法和正向着色法了。这真是太棒了，我们现在可以应用混合或者渲染需要特殊着色器效果的物体了，这在延迟渲染中是不可能做到的。</p><h2 id="更多的光源"><a href="#更多的光源" class="headerlink" title="更多的光源"></a>更多的光源</h2><p>延迟渲染一直被称赞的原因就是它能够渲染大量的光源而不消耗大量的性能。然而，延迟渲染它本身并不能支持非常大量的光源，因为我们仍然必须要对场景中每一个光源计算每一个片段的光照分量。真正让大量光源成为可能的是我们能够对延迟渲染管线引用的一个非常棒的优化：光体积(Light Volumes)</p><p>通常情况下，当我们渲染一个复杂光照场景下的片段着色器时，我们会计算场景中每一个光源的贡献，不管它们离这个片段有多远。很大一部分的光源根本就不会到达这个片段，所以为什么我们还要浪费这么多光照运算呢？</p><p>隐藏在光体积背后的想法就是计算光源的半径，或是体积，也就是光能够到达片段的范围。由于大部分光源都使用了某种形式的衰减(Attenuation)，我们可以用它来计算光源能够到达的最大路程，或者说是半径。我们接下来只需要对那些在一个或多个光体积内的片段进行繁重的光照运算就行了。这可以给我们省下来很可观的计算量，因为我们现在只在需要的情况下计算光照。</p><p>这个方法的难点基本就是找出一个光源光体积的大小，或者是半径。</p><p>计算一个光源的体积或半径<br>为了获取一个光源的体积半径，我们需要解一个对于一个我们认为是黑暗(Dark)的亮度(Brightness)的衰减方程，它可以是0.0，或者是更亮一点的但仍被认为黑暗的值，像是0.03。为了展示我们如何计算光源的体积半径，我们将会使用一个在投光物这节中引入的一个更加复杂，但非常灵活的衰减方程：<br>Flight&#x3D;IKc+Kl∗d+Kq<br>我们现在想要在Flight<br>等于0的前提下解这个方程，也就是说光在该距离完全是黑暗的。然而这个方程永远不会真正等于0.0，所以它没有解。所以，我们不会求表达式等于0.0时候的解，相反我们会求当亮度值靠近于0.0的解，这时候它还是能被看做是黑暗的。在这个教程的演示场景中，我们选择5&#x2F;256<br>作为一个合适的光照值；除以256是因为默认的8-bit帧缓冲可以每个分量显示这么多强度值(Intensity)。</p>]]></content>
    
    
    <categories>
      
      <category>render</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lighting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode配置cpp调试环境</title>
    <link href="/2020/04/12/vscode%E9%85%8D%E7%BD%AEcpp%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
    <url>/2020/04/12/vscode%E9%85%8D%E7%BD%AEcpp%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h3 id="安装vscode插件"><a href="#安装vscode插件" class="headerlink" title="安装vscode插件"></a>安装vscode插件</h3><pre><code class="hljs">1. c/c++2. cmake3. cmake-tool</code></pre><h3 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install cmake clang gdb<br></code></pre></td></tr></table></figure><h3 id="配置vscode"><a href="#配置vscode" class="headerlink" title="配置vscode"></a>配置vscode</h3><ol><li>c_cpp_properties.json</li></ol><p>菜单栏【查看】【命令面板…】<br> 输入关键词”C&#x2F;C++ edit”，选择匹配到的命令”C&#x2F;C++: Edit Configurations (json)”</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Linux&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;includePath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;defines&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;compilerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/clang++&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;cStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c11&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;cppStandard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;c++11&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;intelliSenseMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;default&#125;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;configurationProvider&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ms-vscode.cmake-tools&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">4</span><br>    <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>添加task.json</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2.0.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>    <span class="hljs-comment">//需要进入到我们执行tasks任务的文件夹中</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;tasks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mkdir&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mkdir&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;-p&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;build&quot;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;shell&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cmake&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;..&quot;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;make&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;group&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;isDefault&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;options&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;make&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;-j4&quot;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;label&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;dependsOrder&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sequence&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;dependsOn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br><span class="hljs-string">&quot;mkdir&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;cmake&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;make&quot;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p> 这里实际上将手动的make过程程序化，有需要可以对task任务加减，如：添加rm -rf CMakeCache.txt命令</p></li><li><p>添加launch.json</p><p> 实际的调试入口，启动task任务</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-comment">// 使用 IntelliSense 了解相关属性。 </span><br><span class="hljs-comment">// 悬停以查看现有属性的描述。</span><br><span class="hljs-comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;C++ launch&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build/viewer/gltf-viewer&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span>  <span class="hljs-string">&quot;将反汇编风格设置为 Intel&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;preLaunchTask&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;build&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/gdb&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>写好CMakeLists.txt</p><p>ctrl+shift+D 点击launch任务</p><p>done</p>]]></content>
    
    
    <categories>
      
      <category>config</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debian配置手册</title>
    <link href="/2020/04/10/debian%E9%85%8D%E7%BD%AE%E6%89%8B%E5%86%8C/"/>
    <url>/2020/04/10/debian%E9%85%8D%E7%BD%AE%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<ol><li>配置clash</li></ol><ul><li><p>网络代理配置</p><ul><li>设置-&gt;网络-&gt;网络代理  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">http 127.0.0.1 7890<br>https 127.0.0.1 7890<br>socket 127.0.0.1 7891<br></code></pre></td></tr></table></figure> <img src="/2020/04/10/debian%E9%85%8D%E7%BD%AE%E6%89%8B%E5%86%8C/net_setting.png"></li></ul></li><li><p>开机自启</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nano /etc/systemd/system/clash.service<br></code></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[Unit]<br>Description=A rule based proxy <span class="hljs-keyword">in</span> Go <span class="hljs-keyword">for</span> %i.<br>After=network.target<br><br>[Service]<br>Type=simple<br>User=berg<br>Restart=on-abort<br>ExecStart=/home/berg/.clash/clash -d /home/berg/.clash/<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> clash<br><span class="hljs-comment">#查看状态</span><br>sudo systemctl status clash<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><p>修改默认文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">mkdir</span> Desktop Download Templates Public Documents Music Pictures Videos<br><span class="hljs-built_in">rm</span> -rf 公共 模板 视频 图片 文档 下载 音乐 桌面<br>xdg-user-dirs-update --<span class="hljs-built_in">set</span> DESKTOP ~/Desktop<br>xdg-user-dirs-update --<span class="hljs-built_in">set</span> DOWNLOAD ~/Download<br>xdg-user-dirs-update --<span class="hljs-built_in">set</span> TEMPLATES ~/Templates<br>xdg-user-dirs-update --<span class="hljs-built_in">set</span> PUBLICSHARE ~/Public<br>xdg-user-dirs-update --<span class="hljs-built_in">set</span> DOCUMENTS ~/Documents<br>xdg-user-dirs-update --<span class="hljs-built_in">set</span> MUSIC ~/Music<br>xdg-user-dirs-update --<span class="hljs-built_in">set</span> PICTURES ~/Pictures<br>xdg-user-dirs-update --<span class="hljs-built_in">set</span> VIDEOS ~/Videos<br></code></pre></td></tr></table></figure></li><li><p>安装oh-my-zsh</p></li></ol><ul><li><p>安装zsh</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install zsh<br>chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><p>  重启电脑</p></li><li><p>下载 oh-my-zsh安装脚本</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh<br></code></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x install.sh<br>sh install.sh<br></code></pre></td></tr></table></figure></li><li><p>安装插件</p><ol><li>安装zsh-syntax-highlighting  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure></li><li>安装zsh-autosuggestions  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="hljs-variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure></li><li>修改&#x2F;~.zshrc  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">plugins=(git zsh-syntax-highlighting zsh-autosuggestions)<br></code></pre></td></tr></table></figure></li></ol></li><li><p>配置主题显示当前文件路径 - robbyrussell</p><ul><li>修改主题  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nano ~/.oh-my-zsh/themes/robbyrussell.zsh-theme<br></code></pre></td></tr></table></figure>  更改为以下内容  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">local</span> ret_status=<span class="hljs-string">&quot;%(?:%&#123;<span class="hljs-variable">$fg_bold</span>[green]%&#125;➜ :%&#123;<span class="hljs-variable">$fg_bold</span>[red]%&#125;➜ )&quot;</span><br>PROMPT=<span class="hljs-string">&#x27;$&#123;ret_status&#125; %&#123;$fg[cyan]%&#125;$PWD%&#123;$reset_color%&#125; $(git_prompt_info)&#x27;</span><br>ZSH_THEME_GIT_PROMPT_PREFIX=<span class="hljs-string">&quot;%&#123;<span class="hljs-variable">$fg_bold</span>[blue]%&#125;git:(%&#123;<span class="hljs-variable">$fg</span>[red]%&#125;&quot;</span><br>ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="hljs-string">&quot;%&#123;<span class="hljs-variable">$reset_color</span>%&#125; &quot;</span><br>ZSH_THEME_GIT_PROMPT_DIRTY=<span class="hljs-string">&quot;%&#123;<span class="hljs-variable">$fg</span>[blue]%&#125;) %&#123;<span class="hljs-variable">$fg</span>[yellow]%&#125;✗&quot;</span><br>ZSH_THEME_GIT_PROMPT_CLEAN=<span class="hljs-string">&quot;%&#123;<span class="hljs-variable">$fg</span>[blue]%&#125;)&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><ol start="4"><li>修改grub引导主题</li></ol><ul><li><p>下载主题文件</p><p>  <a href="https://www.gnome-look.org/browse/">https://www.gnome-look.org/browse/</a></p><p>  grub-themes</p></li><li><p>放置主题文件</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /usr/share/grub/themes/vimix<br>sudo <span class="hljs-built_in">cp</span> /your/path/vimix /usr/share/grub/themes/vimix -rf<br></code></pre></td></tr></table></figure></li><li><p>修改系统配置</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/default/grub<br></code></pre></td></tr></table></figure>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GRUB_THEME=<span class="hljs-string">&quot;/usr/share/grub/themes/vimix/theme.txt&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>更新配置</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-grub<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>config</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>debian搭建github博客手册</title>
    <link href="/2020/01/17/debian%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E6%89%8B%E5%86%8C/"/>
    <url>/2020/01/17/debian%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<ol><li><p>安装npm node.js</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install node.js npm<br></code></pre></td></tr></table></figure></li><li><p>安装 hexo</p> <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo<br><br>验证 hexo<br>hexo -v<br></code></pre></td></tr></table></figure></li><li><p>创建blog仓库</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> blog_repo_name<br><span class="hljs-built_in">cd</span> blog_repo_name<br>hexo init<br></code></pre></td></tr></table></figure></li><li><p>安装主题 </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#此方法安装的主题文件位于node_modules，亦可下载主题包放在themes文件下,效果一致</span><br>npm install --save hexo-theme-fluid <br></code></pre></td></tr></table></figure></li><li><p>使用主题</p><p> 修改_config.yml</p> <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">#将主题指定为所需主题</span><br><span class="hljs-symbol">theme:</span> fluid<br></code></pre></td></tr></table></figure></li><li><p>配置主题</p><p> 根据需要修改 node_modules&#x2F;hexo-theme-fluid&#x2F;_config.yml</p></li><li><p>生成网页</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#清除旧的网页</span><br>hexo c<br><br><span class="hljs-comment">#生成静态网页</span><br>hexo g<br><br><span class="hljs-comment">#本地查看静态网页</span><br>hexo s<br></code></pre></td></tr></table></figure></li><li><p>部署到github</p><ul><li><p>安装部署依赖</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure></li><li><p>修改 _config.yml</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">    type:</span> git<br><span class="hljs-symbol">    repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta">#https:<span class="hljs-comment">//bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="hljs-symbol">    branch:</span> [branch]<br></code></pre></td></tr></table></figure></li><li><p>提交</p> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#本地查看网页满意后提交</span><br><span class="hljs-attribute">hexo</span> d<br></code></pre></td></tr></table></figure></li></ul></li><li><p>更改域名</p><ul><li><p>找到某域名服务网站，选购所需域名。</p></li><li><p>更改解析内容</p><ul><li>添加4条 a记录指向以下ip  <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">185.199.108.153</span><br><span class="hljs-number">185.199.109.153</span><br><span class="hljs-number">185.199.110.153</span><br><span class="hljs-number">185.199.111.153</span><br></code></pre></td></tr></table></figure></li><li>添加一条CNAME记录指向yourname.github.io</li></ul></li><li><p>更改github设置</p><ul><li>点击仓库<br>   setting-&gt;pages-&gt;Custom domain，将域名输入，等待解析dns进程完成，再进入域名查看是否成功。</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>config</category>
      
    </categories>
    
    
    <tags>
      
      <tag>debian</tag>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
